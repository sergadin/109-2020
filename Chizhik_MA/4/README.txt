Функции taylor_exp, taylor_sin, taylor_cos, taylor_log основаны на последовательном суммировании ряда Тейлора -
они не используют ни M_E, ни M_PI: заметим, что слагаемые рядов для элементарных функций могут быть 
сравнительно легко выражены рекуррентно, поэтому нет необходимости каждый раз возводить переменную в большую 
степень и делить на большой факториал, это повышало бы вероятность ошибки вычисления.
Однако для значений, далеких от нуля, непосредственное вычисление по формуле Тейлора может происходить 
либо очень долго, либо (в случае логарифма) - вообще не выполняться для x > 2. 
Поэтому были написаны функции effective_*:
1) e^x = e^([x] + {x}) = e^[x] * e^{x}, где [x] - целая часть числа, а {x} = x - [x] - дробная часть числа. 
Здесь мы используем M_E и возводим ее в целую степень, а дробную часть считаем суммированием ряда Тейлора
(используя taylor_exp);
2) sin(-x) = -sin(x), sin(x) = sin(x - 2πn), где n - целое число. Поэтому делаем аргумент положительным
(вынося при необходимости аргумент за скобки), вычитаем 2π до тех пор, пока агрумент не станет <π 
(он может стать отрицательным, но нам важно, чтобы аргумент оказался в промежутке [-π; π] - 
там, где он лучше всего приближается рядом Тейлора), а затем считаем для полученного аргумента taylor_sin;
3) cos(-x) = cos(x), cos(x) = cos(x - 2πn), n - целое число. Проделываем аналогичные действия 
(только знак выносить не нужно в силу четности косинуса), к "улучшенному" аргументу применяем taylor_cos;
4) И, наконец, ln(x). Его можно приблизить, если 0 < x < 2. Поэтому отрицательные аргументы 
отсеиваем в силу ОДЗ логарифма, а в случае, если x > 2, начинаем его делить на корень из e до тех пор, 
пока аргумент не станет <1.65 (чтобы можно было приблизить рядом Тейлора достаточно быстро;
каждое такое деление прибавляет 1/2 к результату). Для полученного аргумента 0 < x <= 1.65 вызываем taylor_log.
